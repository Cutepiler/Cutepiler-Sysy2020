# TAC Document

## Instructions of the TAC
| Instruction | P1 | P2 | P3 | Information |
| --- | --- | --- | --- | --- |
| Neg P1, P2 | register | register / immediate | | arithmetic negtive: `P1 := -P2` |
| Add P1, P2, P3 | register | register / immediate | register / immediate | addition: `P1 := P2 + P3` |
| Sub P1, P2, P3 | register | register / immediate | register / immediate | subtraction: `P1 := P2 - P3` |
| Mul P1, P2, P3 | register | register / immediate | register / immediate | multplication: `P1 := P2 * P3` |
| Div P1, P2, P3 | register | register / immediate | register / immediate | division: `P1 := P2 / P3` |
| Mod P1, P2, P3 | register | register / immediate | register / immediate | modulation: `P1 := P2 mod P3` |
| Gt P1, P2, P3 | register | register / immediate | register / immediate | greater than: `P1 := P2 > P3` |
| Lt P1, P2, P3 | register | register / immediate | register / immediate | less than: `P1 := P2 < P3` |
| Ge P1, P2, P3 | register | register / immediate | register / immediate | greater or equal to: `P1 := P2 >= P3` |
| Le P1, P2, P3 | register | register / immediate | register / immediate | less or equal to: `P1 := P2 <= P3` |
| Eq P1, P2, P3 | register | register / immediate | register / immediate | equal to: `P1 := P2 == P3` |
| Ne P1, P2, P3 | register | register / immediate | register / immediate | not equal to: `P1 := P2 != P3` |
| Not P1, P2 | register | register / immediate | | logical not: `P1 := not P2` |
| And P1, P2, P3 | register | register / immediate | register / immediate | logical and: `P1 := P2 and P3` |
| Or P1, P2, P3 | register | register / immediate | register / immediate | logical or: `P1 := P2 or P3` |
| Branch P1 | label | | | jump to P1 |
| Beqz P1, P2 | register / immediate | label | | jump to P2 if P1 is equal to 0 |
| Bnez P1, P2 | register / immediate | label | | jump to P2 if P1 is not equal to 0 |
| Ret | | | | leave the function with no result |
| Ret P1 | register / immediate | | | leave the function with return value P1 |
| Load P1, P2, P3 | register | register / immediate | immediate | `P1 = Base(P3)[P2]` |
| Store P1, P2, P3 | register / immediate | register / immediate | immediate | `Base(P3)[P2] = P1` |
| Addr P1, P2, P3 | register | register / immediate | immediate | get relative address: `P1 = Base(P3) + P2` |
| Labl P1 | label | | | label |
| Param P1 | register / immediate | immediate | | push P1 into stack, param id is P2 (starting from 1) |
| Call P1 | register / immediate | | | call function of id P1 |
| Call P1, P2 | register / immediate | register | | call function of id P1 and assign P2 with return value |
| Mov P1, P2 | register | register / immediate | | assignment: `P1 := P2` |

- `Base(0) = 0`

## Low-Level Instructions

These instructions are generated by optimizer, each of which can be directly translated to a single ARMv7 instruction. Most of these instructions share the same name with their corresponding ARMv7 instructions.

| Name   | P1       | P2                   | P3                   | P4        | Information                                                  |
| ------ | -------- | -------------------- | -------------------- | --------- | ------------------------------------------------------------ |
| ASL    | register | register             | register / immediate |           | Arithmetic left shift, i.e.`P1 := P2 << P3`                  |
| ASR    | register | register             | register / immediate |           | Arithmetic right shift, i.e. `P1 := P2 >> P3`                |
| LSR    | register | register             | register / immediate |           | Logical right shift, i.e. `P1 := (unsigned)P2 >> (unsigned)P3` |
| MLA    | register | register             | register             | register  | `P1 := P2*P3 + P4`                                           |
| MLS    | register | register             | register             | register  | `P1 := P2*P3 - P4`                                           |
| AddLS  | register | register | register             | immediate | `P1 := P2 + (P3 << P4)`                                      |
| SubLS  | register | register | register             | immediate | `P1 := P2 - (P3 << P4)`                                      |
| RsbLS  | register | register | register             | immediate | `P1 := (P3 << P4) - P2`                                      |
| AddLSR | register | register | register             | immediate | Addition with logically shifted operand, i.e.  `P1 := P2 + ((unsigned)P3 >> (unsigned) P4) ` |
| RsbASR | register | register | register             | immediate | Reversed subtraction with arithmetically shifted operand, i.e. `P1 := (P3 >> P4) - P2` |
| BIC    | register | register             | register / immediate |           | bic in ARMv7, `P1 := P2 & (~P3)`                             |
| Smmul  | register | register             | register             |           | smmul in ARMv7, `P1 := (long long)P2 * P3 >> 32`             |

